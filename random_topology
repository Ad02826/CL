#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv4-address-helper.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/on-off-helper.h"
#include "ns3/packet-sink-helper.h"
#include <fstream>

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("RandomTopologySimulation");

void WriteFlowMonitorDataToCSV(Ptr<FlowMonitor> monitor, double simTime, Ipv4InterfaceContainer interfaces) {
    NS_LOG_INFO("正在将FlowMonitor数据写入CSV文件...");
    std::ofstream outputFile("/srv/samba/ns3_share/network_metrics.csv");
    if (outputFile.is_open()) {
        NS_LOG_INFO("成功打开文件进行写入。");
        outputFile << "FlowID,SourceAddress,DestinationAddress,PacketsSent,PacketsReceived,BytesSent,BytesReceived,Throughput,SimulationTime,RTT,LossType\n";

        std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();
        NS_LOG_INFO("已获取流量统计数据，总流量数量：" << stats.size());

        for (auto &flow : stats) {
            FlowId flowId = flow.first;
            FlowMonitor::FlowStats stat = flow.second;

            // 获取源和目标地址
            Ipv4Address sourceAddr = interfaces.GetAddress(flowId % interfaces.GetN()); // 根据流ID获取源地址
            Ipv4Address destAddr = interfaces.GetAddress((flowId + 1) % interfaces.GetN()); // 根据流ID获取目标地址

            // 计算吞吐量 (每秒字节数)
            double throughput = (stat.rxBytes * 8.0) / (stat.timeLastRxPacket.GetSeconds() - stat.timeFirstTxPacket.GetSeconds());

            // 计算RTT（往返时间）
            double rtt = (stat.timeLastRxPacket.GetSeconds() - stat.timeFirstTxPacket.GetSeconds()) * 1000.0; // 转换为毫秒

            // 判断丢包类型
            std::string lossType = "Unknown";
            if (stat.lostPackets > 0) {
                if (stat.txPackets > stat.rxPackets) {
                    lossType = "Congestion";
                } else {
                    lossType = "Random";
                }
            }

            outputFile << flowId << ","
                       << sourceAddr << ","
                       << destAddr << ","
                       << stat.txPackets << ","
                       << stat.rxPackets << ","
                       << stat.txBytes << ","
                       << stat.rxBytes << ","
                       << throughput << ","
                       << simTime << ","
                       << rtt << ","
                       << lossType << "\n";
        }
        outputFile.close();
        NS_LOG_INFO("FlowMonitor数据成功写入CSV文件。");
    } else {
        NS_LOG_ERROR("无法打开文件进行写入FlowMonitor数据。");
    }
}

int main(int argc, char *argv[]) {
    uint32_t numNodes = 50;  // 默认节点数
    double simTime = 30;   // 默认仿真时间 1小时

    Time::SetResolution(Time::NS);
    LogComponentEnable("RandomTopologySimulation", LOG_LEVEL_INFO);

    NS_LOG_INFO("仿真开始...");

    NodeContainer nodes;
    nodes.Create(numNodes);
    NS_LOG_INFO("成功创建 " << numNodes << " 个节点。");

    CsmaHelper csma;
    csma.SetChannelAttribute("DataRate", StringValue("100Mbps"));
    csma.SetChannelAttribute("Delay", TimeValue(MilliSeconds(2)));

    NetDeviceContainer devices;
    devices = csma.Install(nodes);
    NS_LOG_INFO("成功安装CSMA网络设备。");

    InternetStackHelper internet;
    internet.Install(nodes);
    NS_LOG_INFO("成功安装Internet协议栈。");

    Ipv4AddressHelper ipv4;
    ipv4.SetBase("10.1.0.0", "255.255.255.0");
    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);
    NS_LOG_INFO("成功给节点分配IPv4地址。");

    uint16_t port = 9;
    OnOffHelper onoff("ns3::TcpSocketFactory", Address());
    onoff.SetAttribute("DataRate", StringValue("500kb/s"));
    onoff.SetAttribute("PacketSize", UintegerValue(1024));
    onoff.SetAttribute("MaxBytes", UintegerValue(0));

    ApplicationContainer apps;
    for (uint32_t i = 0; i < numNodes; ++i) {
        AddressValue remoteAddress(InetSocketAddress(interfaces.GetAddress((i + 1) % numNodes), port));
        onoff.SetAttribute("Remote", remoteAddress);
        apps.Add(onoff.Install(nodes.Get(i)));

        PacketSinkHelper sinkHelper("ns3::TcpSocketFactory", InetSocketAddress(Ipv4Address::GetAny(), port));
        ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get((i + 1) % numNodes));
        sinkApp.Start(Seconds(0.0));
        sinkApp.Stop(Seconds(simTime));
    }

    apps.Start(Seconds(1.0));
    apps.Stop(Seconds(simTime));

    NS_LOG_INFO("随机流量生成应用已启动。");

    FlowMonitorHelper flowmon;
    Ptr<FlowMonitor> monitor = flowmon.InstallAll();

    Simulator::Stop(Seconds(simTime));
    NS_LOG_INFO("开始运行仿真... 总时间: " << simTime << "秒");
    Simulator::Run();
    NS_LOG_INFO("仿真完成。");

    WriteFlowMonitorDataToCSV(monitor, simTime, interfaces);

    Simulator::Destroy();
    NS_LOG_INFO("仿真结束并销毁。");
    return 0;
}
